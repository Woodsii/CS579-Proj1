1-28-26

# brute forcing suspected shift ciphers with freq analysis.

# print_byte_counts(freqs, [i for i in range(0, 20)])

letter_frequencies = [
    12.02, 9.10, 8.12, 7.68, 7.31, 6.95, 6.28, 6.02, 5.92, 4.32, 
    3.98, 2.88, 2.71, 2.61, 2.30, 2.11, 2.09, 2.03, 1.82, 1.49, 
    1.11, 0.69, 0.17, 0.11, 0.10, 0.07
]

letters = [
    'e', 't', 'a', 'o', 'i', 'n', 's', 'r', 'h', 'd', 
    'l', 'u', 'c', 'm', 'f', 'y', 'w', 'g', 'p', 'b', 
    'v', 'k', 'x', 'q', 'j', 'z'
]

results = []

print(list(freqs[0].keys())) 
# whalep that didn't work. 

for i, dic in enumerate(freqs):
    # 1. Clean & Decode: Convert bytes to lowercase strings and filter for letters
    # We use .isalpha() to ensure we aren't trying to map punctuation/numbers
    decoded_dic = {}
    for k, v in dic.items():
        char = chr(k).lower()
        if char.isalpha():
            decoded_dic[char] = v

    # 2. Sort the current cipher counts by frequency (descending)
    sorted_cipher_chars = sorted(decoded_dic.items(), key=lambda item: item[1], reverse=True)
    
    # 3. Create the Mapping
    # We take the sorted keys from the cipher and zip them with your 'letters' reference
    # sorted_cipher_chars looks like: [('q', 120), ('x', 90), ...]
    current_mapping = {}
    for j, (cipher_char, count) in enumerate(sorted_cipher_chars):
        if j < len(letters):
            # Maps the cipher character to the expected English letter
            current_mapping[cipher_char] = letters[j]

    # Now lets decrypt! 
    ctxt = ctxts[i].decode('utf-8')
    res = ''

    for c in ctxt:
        if c.isalpha():
            res += current_mapping[c]
        else: 
            res += c
    
    results.append((i, res))

# ok now we have a dictionary of possible mappings. COOL!
for i in range(0, 20): 
    if results[i][1].isnumeric():
        continue
    print(f'--ciphertext {i}--\n{results[i][1]}\n')